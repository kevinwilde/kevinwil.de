---
title: Differences in output of Typescript compiler and Babel for classes
date: "2020-01-13"
description: ""
---

Recently, I worked on switching our entire frontend codebase from using ts-loader to use babel-loader. In doing so, I ran into some discrepancies in the compiled output of classes using the Typescript compiler vs. Babel.

## Background

Originally (before my time) at Course Hero, we were building our react apps using both ts-loader and babel-loader. ts-loader would compile Typescript to ES6, then babel-loader would transpile ES6 to ES5. However, since the Typescript compiler can target es6 directly, another engineer removed babel from the build process so that we were just using ts-loader. This was simpler and also improved the speed of builds.

Not long after this, though, @babel/preset-typescript was released, and it became very easy to compile Typescript to Javascript with Babel. The main reason I wanted to make this change was so that we could use [react-refresh](https://twitter.com/dan_abramov/status/1144630328142831616).

Switching from ts-loader to babel-loader is pretty straightforward for the most part -- swap out ts-loader with babel-loader in the webpack config. However, there are a couple things to be aware of. [Microsoft's blog post](https://devblogs.microsoft.com/typescript/typescript-and-babel-7/) about using Typescript and Babel 7 points out that namespaces and const enums don't work with Babel. I also saw this mentioned in several other articles. If you're worried about this, I wouldn't be. A PM on the Typescript team [explained why it's no big deal here](https://github.com/facebook/create-react-app/pull/4837#issuecomment-430107471).

However, there were two other surprising differences that I ran into. These were more difficult to debug because, unlike the examples above, Babel will successfully compile the code. But the output is noticably different than that of the Typescript compiler.

## 1. Enumerability of class methods

When Typescript compiles classes, it marks class methods enumerable. This is not in line with the spec for ES6 classes, which says that class methods should be non enumerable. When compiling typescript code with babel, class methods are marked non enumerable.
See https://github.com/microsoft/TypeScript/issues/782

This was an issue for us because we had a custom flux framework that used for .. in loops on instances of classes to copy their methods -- details are not important

Fixes:
- class properties instead of class methods
- getOwnPropertyNames would probably also work


## 2. Uninitialized class properties

When Typescript compiles classes, it doesn't generate any code for uninitialized class properties.

Input:
```ts
class ImplicitlyUndefinedProperties {
    public foo: string;
    public bar: string;
}
```

Output:
```ts
var ImplicitlyUndefinedProperties = (function () {
    function ImplicitlyUndefinedProperties() {
    }
    return ImplicitlyUndefinedProperties;
}());
```

This is inconsistent with the spec for ES6 classes, which says that these properties should be initialized as undefined. Babel does this correctly.

The constructor of BaseModel copies over the data passed to it onto `this`. However, when using Babel, the class properties then get overwritten when they are initialized as undefined. You can imagine that the code Typescript generates is like

```ts
class Subclass extends BaseModel {
  constructor(data) {
    super(data)
  }
}
```

and the code generated by Babel is like

```ts
class Subclass extends BaseModel {
  constructor(data) {
    super(data)
    this.property1 = undefined
    this.property2 = undefined
  }
}
```

Related links:
- https://github.com/microsoft/TypeScript/issues/12437
- https://github.com/microsoft/TypeScript/issues/28823


Fixes:
- Static create method instead of constructor
    ```ts
    static create(data) {
        const instance = new this();
        Object.assign(instance, data);
        return instance;
    }

    // and used as...
    MyObject.create({ id: 1, name: 'test' })
    ```
- In order to fix this, I just added a constructor to all classes that extend BaseModel, so that the properties in the argument to the constructor get re-copied onto `this`.
- Default value of property is itself
```ts
    class MyObject extends BaseModel {
        id : number = this.id
        name : string = this.name
    }
```
