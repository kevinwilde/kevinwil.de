{"data":{"site":{"siteMetadata":{"title":"Kevin Wilde","author":"Kevin Wilde"}},"markdownRemark":{"id":"9aaa6b82-539f-5b17-a44c-d6562a5748cf","excerpt":"Course Hero’s main website is (for the most part) one large Symfony application. Symfony is a PHP framework, though the intricacies of it will not be important…","html":"<p>Course Hero’s main website is (for the most part) one large Symfony application. Symfony is a PHP framework, though the intricacies of it will not be important for this article. The one thing we need to cover is the role that Assetic plays within a Symfony application.</p>\n<p><a href=\"https://symfony.com/doc/2.7/frontend/assetic/asset_management.html\">Assetic</a> is used to manage static web assets such as JavaScript, CSS, and image files. It was created in the pre-Webpack era, when JavaScript was sprinkled on a page to add interactivity rather than used to power your whole app and frontend build tooling was limited. (In modern versions of Symfony, Assetic is deprecated in favor of a solution built on top of Webpack.) When using Assetic, JavaScript files are included on the page via the <code class=\"language-text\">javascripts</code> tag inside a Twig template.</p>\n<div class=\"gatsby-highlight\" data-language=\"html\"><pre class=\"language-html\"><code class=\"language-html\">{% javascripts\n    \"@quill_editor_js\"\n    \"../../js/dist/homepage/app.js\"\n    \"../../Control/assets/js/analytics/EventTracking.js\"\n    \"../../Control/assets/js/vendor/ng/select/select.js\"\n    \"../../Control/assets/js/vendor/ng/select/angular-sanitize.js\"\n    \"../../Control/assets/js/vendor/jquery.readmore.js\"\n    \"../../Control/assets/js/vendor/owl.carousel.min.js\"\n    \"@CourseHeroBookBundle/Resources/assets/js/Video/youtube-player-factory.js\"\n    \"@CourseHeroMarketingBundle/Resources/assets/js/HomepageAmplitudeTracking.js\"\n%}\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>script</span> <span class=\"token attr-name\">type</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>text/javascript<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">src</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>{{ asset_url }}<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span><span class=\"token script\"></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>script</span><span class=\"token punctuation\">></span></span>\n{% endjavascripts %}</code></pre></div>\n<p>In this example, we pass a handful of JavaScript files to the <code class=\"language-text\">javascripts</code> tag. Assetic concatenates these files into a single asset and generates a hashed <code class=\"language-text\">asset_url</code> which is what ultimately appears in the <code class=\"language-text\">src</code> attribute of the script tag in the html that is sent to a user’s browser.</p>\n<p>In a scenario where we are using Webpack to build a JavaScript app, however, the benefit of Assetic concatenating our assets together is greatly reduced. Webpack already bundles our source files, so we don’t really need Assetic to do that anymore. As such, when we started building larger features of our site with React and using Webpack to bundle our code, the <code class=\"language-text\">javascripts</code> tag in the Twig file often looked more like</p>\n<div class=\"gatsby-highlight\" data-language=\"html\"><pre class=\"language-html\"><code class=\"language-html\">{% javascripts\n    \"../../js/dist/qa-landing/app.js\"\n%}\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>script</span> <span class=\"token attr-name\">type</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>text/javascript<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">src</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>{{ asset_url }}<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span><span class=\"token script\"></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>script</span><span class=\"token punctuation\">></span></span>\n{% endjavascripts %}</code></pre></div>\n<p>Here we are passing a single JavaScript file to the <code class=\"language-text\">javascripts</code> tag, since it has already been bundled by Webpack. The only reason to use Assetic at this point is so that the script tag’s <code class=\"language-text\">src</code> will be some hashed url, allowing us to tell the browser to cache the file without worrying about a user retrieving a stale version from cache since the url will change if we change the file contents.</p>\n<p>Webpack can also generate a hashed filename, but we would not want to have to pass this hashed filename to the <code class=\"language-text\">javascripts</code> tag in our Twig file because then we would have to update the Twig file with the new hashed filename every time we rebuild our app.</p>\n<div class=\"gatsby-highlight\" data-language=\"html\"><pre class=\"language-html\"><code class=\"language-html\"><span class=\"token comment\">&lt;!-- Obviously bad! --></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>script</span> <span class=\"token attr-name\">type</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>text/javascript<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">src</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>../../js/dist/qa-landing/app.f3cb6eb09bb0fb1b6198.js<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span><span class=\"token script\"></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>script</span><span class=\"token punctuation\">></span></span></code></pre></div>\n<p>Webpack provides solutions to avoid having to do this such as\nHtmlWebpackPlugin, but this plugin did not meet our needs very well.</p>\n<p>So we continued to use Assetic to serve our JavaScript assets, even when the app was already bundled with Webpack.</p>","frontmatter":{"title":"Code Splitting in a Symfony + Assetic codebase","description":""}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/code-splitting/","previous":{"fields":{"slug":"/incremental-migration/"},"frontmatter":{"title":"Incremental Migration"}},"next":{"fields":{"slug":"/differences-in-output-of-typescript-compiler-and-babel-for-classes/"},"frontmatter":{"title":"Differences in output of Typescript compiler and Babel for classes"}}}}