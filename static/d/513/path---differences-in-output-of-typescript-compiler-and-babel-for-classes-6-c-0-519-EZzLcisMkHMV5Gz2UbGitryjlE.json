{"data":{"site":{"siteMetadata":{"title":"Kevin Wilde","author":"Kevin Wilde"}},"markdownRemark":{"id":"6ecd6bd8-b597-5438-8588-a04feb5452b4","excerpt":"Recently, I worked on switching our entire frontend codebase from using ts-loader to use babel-loader. In doing so, I ran into some discrepancies in the…","html":"<p>Recently, I worked on switching our entire frontend codebase from using ts-loader to use babel-loader. In doing so, I ran into some discrepancies in the compiled output of classes using the Typescript compiler vs. Babel.</p>\n<h2>Background</h2>\n<p>Originally (before my time) at Course Hero, we were building our react apps using both ts-loader and babel-loader. ts-loader would compile Typescript to ES6, then babel-loader would transpile ES6 to ES5. However, since the Typescript compiler can target es6 directly, another engineer removed babel from the build process so that we were just using ts-loader. This was simpler and also improved the speed of builds.</p>\n<p>Not long after this, though, @babel/preset-typescript was released, and it became very easy to compile Typescript to Javascript with Babel. The main reason I wanted to make this change was so that we could use <a href=\"https://twitter.com/dan_abramov/status/1144630328142831616\">react-refresh</a>. So I started working on switching from using typescript compiler to babel. For most part, it’s pretty straightforward — swap out ts-loader with babel-loader in webpack config.\nGotchas if switching from typescript compiler to babel or some other javascript compiler that implements es6 spec.\nMany people are aware of namespaces and const enums.</p>\n<blockquote>\n<p>Second, there are certain constructs that don’t currently compile in Babel 7. Specifically,</p>\n<ul>\n<li>namespaces</li>\n<li>bracket style type-assertion/cast syntax regardless of when JSX is enabled (i.e. writing <Foo>x won’t work even in .ts files if JSX support is turned on, but you can instead write x as Foo).</li>\n<li>enums that span multiple declarations (i.e. enum merging)</li>\n<li>legacy-style import/export syntax (i.e. import foo = require(…) and export = foo)</li>\n</ul>\n</blockquote>\n<p><a href=\"https://devblogs.microsoft.com/typescript/typescript-and-babel-7/\">https://devblogs.microsoft.com/typescript/typescript-and-babel-7/</a>\nNot a big loss anyway. See comment from typescript PM\n<a href=\"https://github.com/facebook/create-react-app/pull/4837#issuecomment-430107471\">https://github.com/facebook/create-react-app/pull/4837#issuecomment-430107471</a>\nHowever, there were a couple other gotchas I ran into that seem to be less frequently mentioned. Specifically,\n1.\nWhen Typescript compiles classes, it marks class methods enumerable. This is not in line with the spec for ES6 classes, which says that class methods should be non enumerable. When compiling typescript code with babel, class methods are marked non enumerable.\nSee <a href=\"https://github.com/microsoft/TypeScript/issues/782\">https://github.com/microsoft/TypeScript/issues/782</a>\nThis was an issue for us because we had a custom flux framework that used for .. in loops on instances of classes to copy their methods — details are not important\nFixes:</p>\n<ul>\n<li>class properties instead of class methods</li>\n<li>getOwnPropertyNames would probably also work</li>\n<li>2.</li>\n</ul>\n<p>When Typescript compiles classes, it doesn’t generate any code for uninitialized class properties.\nInput\nclass ImplicitlyUndefinedProperties {\npublic foo: string;\npublic bar: string;\n}\nOuput\nvar ImplicitlyUndefinedProperties = (function () {\nfunction ImplicitlyUndefinedProperties() {\n}\nreturn ImplicitlyUndefinedProperties;\n}());\nThis is inconsistent with the spec for ES6 classes, which says that these properties should be initialized as undefined. Babel does this correctly.\nThe constructor of BaseModel copies over the data passed to it onto <code class=\"language-text\">this</code>. However, when using Babel, the class properties then get overwritten when they are initialized as undefined. You can imagine that the code Typescript generates is like\nclass Subclass extends BaseModel {\nconstructor(data) {\nsuper(data)\n}\n}\nand the code generated by Babel is like\nclass Subclass extends BaseModel {\nconstructor(data) {\nsuper(data)\nthis.property1 = undefined\nthis.property2 = undefined\n}\n}\nRelated links:\n<a href=\"https://github.com/microsoft/TypeScript/issues/12437\">https://github.com/microsoft/TypeScript/issues/12437</a>\n<a href=\"https://github.com/microsoft/TypeScript/issues/28823\">https://github.com/microsoft/TypeScript/issues/28823</a>\nFixes:</p>\n<ul>\n<li>Static create method instead of constructor\nstatic create(data) {\nconst instance = new this();\nObject.assign(instance, data);\nreturn instance;\n}\n// and used as…\nMyObject.create({ id: 1, name: ‘test’ })</li>\n<li>In order to fix this, I just added a constructor to all classes that extend BaseModel, so that the properties in the argument to the constructor get re-copied onto <code class=\"language-text\">this</code>.</li>\n<li>Default value of property is itself\nclass MyObject extends BaseModel\n{\nid : number = this.id\nname : string = this.name\n}</li>\n</ul>","frontmatter":{"title":"Differences in output of Typescript compiler and Babel for classes","description":""}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/differences-in-output-of-typescript-compiler-and-babel-for-classes/","previous":{"fields":{"slug":"/incremental-migration/"},"frontmatter":{"title":"Incremental Migration"}},"next":null}}