{"data":{"site":{"siteMetadata":{"title":"Kevin Wilde","author":"Kevin Wilde"}},"markdownRemark":{"id":"9aaa6b82-539f-5b17-a44c-d6562a5748cf","excerpt":"Course Hero’s main website is (for the most part) one large Symfony application. Symfony is a PHP framework, though the intricacies of it will not be important…","html":"<p>Course Hero’s main website is (for the most part) one large Symfony application. Symfony is a PHP framework, though the intricacies of it will not be important for this article. The one thing we need to cover is the role that Assetic plays within a Symfony application.</p>\n<p><a href=\"https://symfony.com/doc/2.7/frontend/assetic/asset_management.html\">Assetic</a> is used to manage static web assets such as JavaScript, CSS, and image files. It was created in the pre-Webpack era, when JavaScript was sprinkled on a page to add interactivity rather than used to power your whole app and frontend build tooling was limited. (In modern versions of Symfony, Assetic is deprecated in favor of a solution built on top of Webpack.) When using Assetic, JavaScript files are included on the page via the <code class=\"language-text\">javascripts</code> tag inside a Twig template.</p>\n<div class=\"gatsby-highlight\" data-language=\"html\"><pre class=\"language-html\"><code class=\"language-html\">{% javascripts\n    \"@quill_editor_js\"\n    \"../../js/dist/homepage/app.js\"\n    \"../../Control/assets/js/analytics/EventTracking.js\"\n    \"../../Control/assets/js/vendor/ng/select/select.js\"\n    \"../../Control/assets/js/vendor/ng/select/angular-sanitize.js\"\n    \"../../Control/assets/js/vendor/jquery.readmore.js\"\n    \"../../Control/assets/js/vendor/owl.carousel.min.js\"\n    \"@CourseHeroBookBundle/Resources/assets/js/Video/youtube-player-factory.js\"\n    \"@CourseHeroMarketingBundle/Resources/assets/js/HomepageAmplitudeTracking.js\"\n%}\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>script</span> <span class=\"token attr-name\">type</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>text/javascript<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">src</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>{{ asset_url }}<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span><span class=\"token script\"></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>script</span><span class=\"token punctuation\">></span></span>\n{% endjavascripts %}</code></pre></div>\n<p>In this example, we pass a handful of JavaScript files to the <code class=\"language-text\">javascripts</code> tag. Assetic concatenates these files into a single asset and generates a hashed <code class=\"language-text\">asset_url</code> which is what ultimately appears in the <code class=\"language-text\">src</code> attribute of the script tag in the html that is sent to a user’s browser.</p>\n<p>In a scenario where we are using Webpack to build a JavaScript app, however, the benefit of Assetic concatenating our assets together is greatly reduced. Webpack already bundles our source files, so we don’t really need Assetic to do that anymore. As such, when we started building larger features of our site with React and using Webpack to bundle our code, the <code class=\"language-text\">javascripts</code> tag in the Twig file often looked more like</p>\n<div class=\"gatsby-highlight\" data-language=\"html\"><pre class=\"language-html\"><code class=\"language-html\">{% javascripts\n    \"../../js/dist/qa-landing/app.js\"\n%}\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>script</span> <span class=\"token attr-name\">type</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>text/javascript<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">src</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>{{ asset_url }}<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span><span class=\"token script\"></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>script</span><span class=\"token punctuation\">></span></span>\n{% endjavascripts %}</code></pre></div>\n<p>Here we are passing a single JavaScript file to the <code class=\"language-text\">javascripts</code> tag, since it has already been bundled by Webpack. The only reason to use Assetic at this point is so that the script tag’s <code class=\"language-text\">src</code> will be some hashed url, allowing us to tell the browser to cache the file without worrying about a user retrieving a stale version from cache since the url will change if we change the file contents.</p>\n<p>Webpack can also generate a hashed filename, but we would not want to have to pass this hashed filename to the <code class=\"language-text\">javascripts</code> tag in our Twig file because then we would have to update the Twig file with the new hashed filename every time we rebuild our app.</p>\n<div class=\"gatsby-highlight\" data-language=\"html\"><pre class=\"language-html\"><code class=\"language-html\"><span class=\"token comment\">&lt;!-- Obviously bad to have to actually write this in source code! --></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>script</span> <span class=\"token attr-name\">type</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>text/javascript<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">src</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>../../js/dist/qa-landing/app.f3cb6eb09bb0fb1b6198.js<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span><span class=\"token script\"></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>script</span><span class=\"token punctuation\">></span></span></code></pre></div>\n<p>Webpack provides solutions to avoid having to do this such as HtmlWebpackPlugin, but this plugin did not meet our needs very well.</p>\n<p>So we continued to use Assetic to serve our JavaScript assets, even when the app was already bundled with Webpack. And for awhile, this worked perfectly well. As we started building larger and larger apps with React, though, I suggested that it would be great if we could leverage <a href=\"https://reactjs.org/docs/code-splitting.html\">code splitting</a> so that users are not downloading a bunch of unnecessary code on page load.</p>\n<p>The React docs show how easy it is to code-split your app via <code class=\"language-text\">React.lazy</code> and the dynamic <code class=\"language-text\">import()</code> syntax. So we can just throw some of those into the appropriate places in our React app, right? Unfortunately, no. When Webpack code-splits your app, it needs to inject code that will load the various chunks when the dynamic import statements execute. As such, it contains references to the relative path and filenames of these chunks. However, since we were still passing our output file to Assetic, these references would be broken when Assetic processed our file and generated a new output file in some other directory with that hashed <code class=\"language-text\">asset_url</code> we talked about. The contents of the file generated by Assetic still referenced the various chunks created by Webpack, but the relative path was no longer correct!</p>\n<p>There were a few ways we could have gone about fixing this. One solution might be to try to fix the relative paths in the file generated by Assetic. This didn’t seem ideal since we’d likely have to do some parsing (whether string parsing or parsing the actual JavaScript code to find the references) and then string manipulation to fix the relative paths. Yuck. A simpler solution might be to simply copy the chunks generated by Webpack into the same output dir that Assetic was writing its output file to. That way, the relative path should be the same. This is a reasonable approach and could probably work well. However, it created some difficulties for us because of the way our build process is optimized to avoid re-building apps which have not changed since the last build. Therefore, we opted for a third approach: to simply stop using Assetic for apps built with Webpack.</p>\n<p>If we go back to the role Assetic was playing for us, I pointed out above that we no longer needed it to concatenate multiple source files since Webpack bundles our source code. The one benefit it was still providing was that we could write a non-hashed filename in our source code and Assetic would turn it into a hashed filename. If there was a way we could do this with Webpack, then we could eliminate the remaining benefit of passing our Webpack-generated assets through Assetic. Conveniently, <a href=\"https://github.com/shellscape/webpack-manifest-plugin\">webpack-manifest-plugin</a> provides just the information we need in order to do this. This plugin produces a JSON file that maps the unhashed filename to the generated, hashed filename.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">{\n    &quot;qa-landing/app.js&quot;: &quot;/assets/js/compiled/qa-landing/app.c97e46a5876bd6275aeb.js&quot;,\n}</code></pre></div>\n<p>Using this information, we can create a <a href=\"https://symfony.com/doc/2.7/templating/twig_extension.html\">custom Twig extension</a> that takes the unhashed filename as input and returns the output path to the hashed file generated by Webpack. This allows us to write <code class=\"language-text\">qa-landing/app.js</code> in our Twig file and turn this into the actual filename automatically.</p>\n<h2>Further notes</h2>\n<ul>\n<li>In our case, this means the Twig file now contains something like</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">{{ &quot;qa-landing/app.js&quot; | webpack_asset }}</code></pre></div>\n<p>and</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">{{ &quot;qa-landing/app.css&quot; | webpack_asset }}</code></pre></div>\n<p><code class=\"language-text\">webpack_asset</code> is our Twig extension, which will translate the unhashed filename into the actual filename, and inject a <code class=\"language-text\">&lt;script&gt;</code> tag for JavaScript files and a <code class=\"language-text\">&lt;link&gt;</code> tag for css files. (In order to have the Twig extension return HTML which should be injected into the Twig file without escaping it, you can use <a href=\"https://twig.symfony.com/doc/2.x/advanced.html#automatic-escaping\">the <code class=\"language-text\">is_safe</code> option</a>.) The benefit</p>\n<p>In order to optimize the performance of the Twig extension, we used a <a href=\"https://symfony.com/doc/2.7/service_container/compiler_passes.html\">Symfony compiler pass</a> to read the webpack manifest JSON files at compile time and keep the mapping from unhashed filename to generated hashed filename in memory. This way, at runtime, the generated hashed filename can be returned from memory rather than needing to read the webpack manifest JSON file from disk on each page request.</p>","frontmatter":{"title":"Code Splitting with React in a Symfony + Assetic codebase","description":""}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/code-splitting/","previous":{"fields":{"slug":"/incremental-migration/"},"frontmatter":{"title":"Incremental Migration"}},"next":{"fields":{"slug":"/differences-in-output-of-typescript-compiler-and-babel-for-classes/"},"frontmatter":{"title":"Differences in output of Typescript compiler and Babel for classes"}}}}