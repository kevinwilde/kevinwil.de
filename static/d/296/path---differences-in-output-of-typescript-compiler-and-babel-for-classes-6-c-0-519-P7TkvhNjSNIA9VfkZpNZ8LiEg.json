{"data":{"site":{"siteMetadata":{"title":"Kevin Wilde","author":"Kevin Wilde"}},"markdownRemark":{"id":"6ecd6bd8-b597-5438-8588-a04feb5452b4","excerpt":"Recently, I worked on switching our entire frontend codebase from using ts-loader to use babel-loader. In doing so, I ran into some discrepancies in the…","html":"<p>Recently, I worked on switching our entire frontend codebase from using ts-loader to use babel-loader. In doing so, I ran into some discrepancies in the compiled output of classes using the Typescript compiler vs. Babel.</p>\n<h2>Background</h2>\n<p>Originally (before my time) at Course Hero, we were building our react apps using both ts-loader and babel-loader. ts-loader would compile Typescript to ES6, then babel-loader would transpile ES6 to ES5. However, since the Typescript compiler can target es6 directly, another engineer removed babel from the build process so that we were just using ts-loader. This was simpler and also improved the speed of builds.</p>\n<p>Not long after this, though, @babel/preset-typescript was released, and it became very easy to compile Typescript to Javascript with Babel. The main reason I wanted to make this change was so that we could use <a href=\"https://twitter.com/dan_abramov/status/1144630328142831616\">react-refresh</a>.</p>\n<p>Switching from ts-loader to babel-loader is pretty straightforward for the most part — swap out ts-loader with babel-loader in the webpack config. However, there are a couple things to be aware of. <a href=\"https://devblogs.microsoft.com/typescript/typescript-and-babel-7/\">Microsoft’s blog post</a> about using Typescript and Babel 7 points out that namespaces and const enums don’t work with Babel. I also saw this mentioned in several other articles. If you’re worried about this, I wouldn’t be. A PM on the Typescript team <a href=\"https://github.com/facebook/create-react-app/pull/4837#issuecomment-430107471\">explained why it’s no big deal here</a>.</p>\n<p>However, there were a two other surprising differences that I ran into. These were more difficult to debug because, unlike the examples, Babel will successfully compile the code. It doesn’t just blow up. But the output is noticably different than that of the Typescript compiler.</p>\n<p>1.\nWhen Typescript compiles classes, it marks class methods enumerable. This is not in line with the spec for ES6 classes, which says that class methods should be non enumerable. When compiling typescript code with babel, class methods are marked non enumerable.\nSee <a href=\"https://github.com/microsoft/TypeScript/issues/782\">https://github.com/microsoft/TypeScript/issues/782</a>\nThis was an issue for us because we had a custom flux framework that used for .. in loops on instances of classes to copy their methods — details are not important\nFixes:</p>\n<ul>\n<li>class properties instead of class methods</li>\n<li>getOwnPropertyNames would probably also work</li>\n<li>2.</li>\n</ul>\n<p>When Typescript compiles classes, it doesn’t generate any code for uninitialized class properties.\nInput\nclass ImplicitlyUndefinedProperties {\npublic foo: string;\npublic bar: string;\n}\nOuput\nvar ImplicitlyUndefinedProperties = (function () {\nfunction ImplicitlyUndefinedProperties() {\n}\nreturn ImplicitlyUndefinedProperties;\n}());\nThis is inconsistent with the spec for ES6 classes, which says that these properties should be initialized as undefined. Babel does this correctly.\nThe constructor of BaseModel copies over the data passed to it onto <code class=\"language-text\">this</code>. However, when using Babel, the class properties then get overwritten when they are initialized as undefined. You can imagine that the code Typescript generates is like\nclass Subclass extends BaseModel {\nconstructor(data) {\nsuper(data)\n}\n}\nand the code generated by Babel is like\nclass Subclass extends BaseModel {\nconstructor(data) {\nsuper(data)\nthis.property1 = undefined\nthis.property2 = undefined\n}\n}\nRelated links:\n<a href=\"https://github.com/microsoft/TypeScript/issues/12437\">https://github.com/microsoft/TypeScript/issues/12437</a>\n<a href=\"https://github.com/microsoft/TypeScript/issues/28823\">https://github.com/microsoft/TypeScript/issues/28823</a>\nFixes:</p>\n<ul>\n<li>Static create method instead of constructor\nstatic create(data) {\nconst instance = new this();\nObject.assign(instance, data);\nreturn instance;\n}\n// and used as…\nMyObject.create({ id: 1, name: ‘test’ })</li>\n<li>In order to fix this, I just added a constructor to all classes that extend BaseModel, so that the properties in the argument to the constructor get re-copied onto <code class=\"language-text\">this</code>.</li>\n<li>Default value of property is itself\nclass MyObject extends BaseModel\n{\nid : number = this.id\nname : string = this.name\n}</li>\n</ul>","frontmatter":{"title":"Differences in output of Typescript compiler and Babel for classes","description":""}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/differences-in-output-of-typescript-compiler-and-babel-for-classes/","previous":{"fields":{"slug":"/incremental-migration/"},"frontmatter":{"title":"Incremental Migration"}},"next":null}}