{"data":{"site":{"siteMetadata":{"title":"Kevin Wilde","author":"Kevin Wilde"}},"markdownRemark":{"id":"9aaa6b82-539f-5b17-a44c-d6562a5748cf","excerpt":"Course Hero’s main website is (for the most part) one large Symfony application. Symfony is a PHP framework, though the intricacies of it will not be important…","html":"<p>Course Hero’s main website is (for the most part) one large Symfony application. Symfony is a PHP framework, though the intricacies of it will not be important for this article. The one thing we need to cover is the role that Assetic plays within a Symfony application.</p>\n<p><a href=\"https://symfony.com/doc/2.7/frontend/assetic/asset_management.html\">Assetic</a> is used to manage static web assets such as JavaScript, CSS, and image files. It was created in the pre-Webpack era, when JavaScript was sprinkled on a page to add interactivity rather than used to power your whole app and frontend build tooling was limited. (In modern versions of Symfony, Assetic is deprecated in favor of a solution built on top of Webpack.) When using Assetic, JavaScript files are included on the page via the <code class=\"language-text\">javascripts</code> tag inside a Twig template.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">{% javascripts\n    &quot;@quill_editor_js&quot;\n    &quot;../../js/dist/homepage/app.js&quot;\n    &quot;../../Control/assets/js/analytics/EventTracking.js&quot;\n    &quot;../../Control/assets/js/vendor/ng/select/select.js&quot;\n    &quot;../../Control/assets/js/vendor/ng/select/angular-sanitize.js&quot;\n    &quot;../../Control/assets/js/vendor/jquery.readmore.js&quot;\n    &quot;../../Control/assets/js/vendor/owl.carousel.min.js&quot;\n    &quot;@CourseHeroBookBundle/Resources/assets/js/Video/youtube-player-factory.js&quot;\n    &quot;@CourseHeroMarketingBundle/Resources/assets/js/HomepageAmplitudeTracking.js&quot;\n%}\n    &lt;script type=&quot;text/javascript&quot; src=&quot;{{ asset_url }}&quot;&gt;&lt;/script&gt;\n{% endjavascripts %}</code></pre></div>\n<p>In this example, we pass a handful of JavaScript files to the <code class=\"language-text\">javascripts</code> tag. Assetic concatenates these files into a single asset and generates a hashed <code class=\"language-text\">asset_url</code> which is what ultimately appears in the <code class=\"language-text\">src</code> attribute of the script tag in the html that is sent to a user’s browser.</p>\n<p>In a scenario where we are using Webpack to build a JavaScript app, however, the benefit of Assetic concatenating our assets together is greatly reduced. Webpack already bundles our source files, so we don’t really need Assetic to do that anymore. As such, when we started building larger features of our site with React and using Webpack to bundle our code, the <code class=\"language-text\">javascripts</code> tag in the Twig file often looked more like</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">{% javascripts\n    &quot;../../js/dist/qa-landing/app.js&quot;\n%}\n    &lt;script type=&quot;text/javascript&quot; src=&quot;{{ asset_url }}&quot;&gt;&lt;/script&gt;\n{% endjavascripts %}</code></pre></div>\n<p>Here we are passing a single JavaScript file to the <code class=\"language-text\">javascripts</code> tag, since it has already been bundled by Webpack. The only reason to use Assetic at this point is so that the script tag’s <code class=\"language-text\">src</code> will be some hashed url, allowing us to tell the browser to cache the file without worrying about a user retrieving a stale version from cache because the url will change if we change the file contents.</p>","frontmatter":{"title":"Code Splitting in a Symfony + Assetic codebase","description":""}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/code-splitting/","previous":{"fields":{"slug":"/incremental-migration/"},"frontmatter":{"title":"Incremental Migration"}},"next":{"fields":{"slug":"/differences-in-output-of-typescript-compiler-and-babel-for-classes/"},"frontmatter":{"title":"Differences in output of Typescript compiler and Babel for classes"}}}}